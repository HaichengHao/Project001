//#include<stdio.h>
//void main() {
//	//处理的流程分析10/4=2.5 ==截取整数==>2==>2.0000000
//	double d1 = 10 / 4;//2，因为两个参与运算的数都是整形，得到的结果会默认去掉小数部分，然后输出不带后面小数的浮点数
//	double d2 = 10.0 / 4;//如果希望保留小数，参与运算数必须有浮点数
//	//取模公式a-a/b*b
//	int res1 = 10 % 3;//取模 
//	int res2 = -10 % 3;//-10-(-10)/3*3 = -10 - (-3)*3=-10+9=-1
//	int res3 = 10 % -3;//10-10/（-3）*（-3）=10-（-3）*（-3）=10-9=1
//	int res4 = -10 % -3;//-10-(-10)/(-3)*(-3)=-10-3*(-3)=-10-(-9)=-10+9=-1
//
//
//
//	//++的使用
//
//	int i = 10;
//	int j = i++;//等价于int j = i;i=i+1;
//	int k = ++i;//底层为i = i+1 ; k = i;
//	printf("\ni = % d, j = % d", i, j);//i=12 j =10
//	printf("\n i=%d,k=%d", i, k);//i=12,k=12，因为上一步i已经自增变成了11，所以这里再自增就变成了12！！！注意陷阱，不要孤立的去看某一段代码
//	printf("d1 = %f,d2 = %f res1 = %d res2 = %d res3 = %d res4 = %d",d1,d2,res1,res2,res3,res4);
//
//	//++ 或者 -- 还可以独立使用，相当于自增/自减
//	k++;//等价于 k = k+1
//	++k;//也等价于 k = k+1
//	//如果独立使用k++和++k完全等价
//	printf("k=%d");//之前求得k=12,所以k经过两次自加后变成了14
//}
///*
//d1 = 2.000000,d2 = 2.500000 res1 = 1 res2 = -1 res3 =1 res4 = -1
//*/